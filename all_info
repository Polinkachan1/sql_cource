//1)Базовый синтаксис SQL запроса  
//Одна из основных функций SQL — это получение выборок данных из СУБД. Для этого в SQL используется оператор SELECT.
//Вывод произвольных значений
SELECT "Hello world"
//Вывод всех данных из таблицы
SELECT * FROM FamilyMembers
//Вывод данных из определённых колонок таблицы
SELECT member_id, member_name FROM FamilyMembers
//Псевдонимы
В случае, если мы хотим вывести какие-то столбцы таблицы, но чтобы в итоговой выборке они были названы иначе, мы можем использовать псевдонимы (их также называют алиасами).
SELECT member_id, member_name AS Name FROM FamilyMembers
ИЛИ
SELECT member_id, member_name Name FROM FamilyMembers
Псевдонимы могут содержать до 255 знаков (включая пробелы, цифры и специальные символы).
2)Литералы в SQL
//Литерал — это указанное явным образом фиксированное значение, например, число 12 или строка "SQL".
//Основными типами литералов в MySQL являются:
строковый
числовой
логический
NULL
литерал даты и времени
//Строковые литералы
//Строка — это последовательность символов, заключённых в одинарные (') или двойные (") кавычки.
SELECT "Строка \n Другая строка" as String
//Числовые литералы
Включает в себя целые и дробные числа. Разделительный знак для дробного числа — «.» (точка).	1, 2.9, 0.01
Может иметь только целую, дробную часть или обе сразу.	.2, 1.1, 10
Может быть положительным и отрицательным числом (для положительного числа совсем не обязательно указывать знак).	+1, -10, -2.2
Могут быть представлены в экспоненциальном виде.	1e3 (=1000) 1e-3 (=0.001)
//Арифметические операторы
//Оператор	Описание	Пример
%, MOD	Деление по модулю	11 % 5 = 1
*	Умножение	10 * 16 = 160
+	Сложение	98 + 2 = 100
-	Вычитание	50 - 51 = -1
/	Деление	1 / 2 = 0.5
DIV	Целочисленное деление	10 DIV 4 = 2
//Пример
SELECT (5 * 2 - 6) / 2 AS Result;
//Литералы даты и времени
//Дата -YYYY-MM-DD, YYYYMMDD
Вместо разделителя "-" можно использовать любой знак препинания.
Например:
'2020-01-01' = 1 января 2020
//Время - hh:mm:ss, hh:mm, hh, ss
Разделитель тоже можно опустить.
Например:
12:11 = 12:11:00
//Дата и время - YYYY-MM-DD hh:mm:ss, YYYYMMDDhhmmss
Например:
'20200101183030' = 1 января 2020, 18:30:30
//Логические литералы
Логический литерал - значения TRUE и FALSE, означающие истинность и ошибочность какого-либо утверждения. При интерпретации запроса, MySQL преобразует их в числа: TRUE и FALSE становятся 1 и 0 соответственно.
//NULL
Значение NULL означает "нет данных", "нет значения". Оно нужно, чтобы отличать визуально пустые значения, такие как строка нулевой длины или "пробел", от того, когда значения вообще нет, даже пустого.
3)Применение функций
SELECT UPPER("Hello world") AS upper_string; - функция UPPER преобразует все буквы строки к верхнему регистру
//Встроенная функция – реализованный в СУБД кусок кода, с помощью которого можно выполнять преобразования строковых, числовых и других данных в запросах.
//функция NOW() принимает ноль аргументов и возвращает литерал в формате даты
//LOWER
SELECT LOWER('SQL Academy') AS lower_string;
Возвращает строку, в которой все символы записаны в нижнем регистре
//YEAR
SELECT YEAR("2022-06-16") AS year;
Возвращает год для указанной даты
//INSTR
SELECT INSTR('sql-academy', 'academy') AS idx;
Осуществляет поиск подстроки в строке, возвращая позицию её первого символа. При этом отсчёт начинается с единицы, а не нуля, как в большинстве языков программирования.
//LENGTH
SELECT LENGTH('sql-academy') AS str_length;
Возвращает длину указанной строки.
//Пример SELECT UPPER(LEFT('sql-academy', 3)) AS str;
//Вывод SQL
//Задачки
1.Выведите текст "Hello world" в нижнем регистре с помощью соответствующей функции- SELECT LOWER("Hello world") AS lower_string
2.Выведите полное имя члена семьи и его год рождения, используя функцию YEAR.SELECT member_name, YEAR(birthday) AS year_of_birth FROM FamilyMembers
3.Выведите полное имя члена семьи и длину его фамилии. SELECT member_name, LENGTH(member_name)-INSTR(member_name,' ') AS lastname_length FROM FamilyMembers
//
4)Исключение дубликатов, DISTINCT
//В некоторых ситуациях SQL запрос на выборку может возвращать повторяющиеся строки данных.
SELECT [DISTINCT] поля_таблиц FROM наименование_таблицы  - Чтобы при выборке избежать такого дублирования, есть оператор DISTINCT.
//То есть в нашем случае запрос на получение уникальных классов, в которых есть хотя бы один студент, будет выглядеть следующим образом: SELECT DISTINCT class FROM Student_in_class;
//При использовании оператора DISTINCT для двух и более колонок будут удаляться записи, которые имеют одинаковые значения по всем полям.
//запрос с оператором DISTINCT вернул бы все сочетания имён и фамилий кроме дублирующихся «John Scott».можно проверять на совпадения нескольких колонок
SELECT DISTINCT first_name, last_name FROM User;
//Задания
1.Выведите только уникальные имена first_name студентов из таблицы Student. SELECT DISTINCT first_name FROM Student
2.Выведите только уникальные пары значений идентификатор учителя teacher и идентификатор предмета subject из таблицы Schedule. SELECT DISTINCT teacher,subject FROM Schedule
//
5)Условный оператор WHERE
//Ситуация, когда требуется сделать выборку по определённому условию, встречается очень часто. Для этого в операторе SELECT существует оператор WHERE, после которого следуют условия для ограничения строк. 
SELECT [DISTINCT] поля_таблиц FROM наименование_таблицы
WHERE условие_на_ограничение_строк
[логический_оператор другое_условие_на_ограничение_строк];
//Пример
SELECT * FROM Student
WHERE first_name = "Grigorij" AND YEAR(birthday) > 2000;
//Операторы сравнения
Оператор	Обозначение	Описание
Равенство	=	Если оба значения равны, то результат будет равен 1, иначе 0
Эквивалентность	<=>	Аналогичен оператору равенства, за исключением того, что результат будет равен 1 в случае сравнения NULL с NULL и 0, когда идёт сравнение любого значения с NULL
Неравенство	<> или !=	Если оба значения не равны, то результат будет равен 1, иначе 0
Меньше	<	Если одно значение меньше другого, то результат будет равен 1, иначе 0
Меньше или равно	<=	Если одно значение меньше или равно другому, то результат будет равен 1, иначе 0
Больше	>	Если одно значение больше другого, то результат будет равен 1, иначе 0
Больше или равно	>=	Если одно значение больше или равно другому, то результат будет равен 1, иначе 0
//Результатом сравнения любого значения с NULL является NULL.
//Логические операторы
Логические операторы необходимы для связывания операторов сравнения.
Оператор	Описание
NOT	Меняет значение оператора сравнения на противоположный
OR	Возвращает общее значение выражения истинно, если хотя бы одно из них истинно
AND	Возвращает общее значение выражения истинно, если они оба истинны
XOR	Возвращает общее значение выражения истинно, если один и только один аргумент является истинным
//Задачки 
1.Выведите идентификаторы товаров (поле good) из таблицы Payments, стоимость которых больше 2000 единиц. Стоимость товара хранится в поле unit_price. 
SELECT good FROM Payments WHERE unit_price>2000
2. Выведите имена (поле member_name) членов семьи из таблицы FamilyMembers, чей статус (поле status) равен "father".
SELECT member_name FROM FamilyMembers WHERE status = 'father'
3.Выведите имя (поле member_name) и дату рождения (поле birthday) членов семьи из таблицы FamilyMembers, чей статус (поле status) равен "father" или "mother".
SELECT member_name, birthday FROM FamilyMembers WHERE status = 'father' or status = 'mother'
4.Необходимо получить все комнаты, в которых есть как кухня (поле has_kitchen), так и интернет (поле has_internet). Напишите запрос, удовлетворяющий вышеописанному условию, который выводит все поля из таблицы Rooms.
Наличие обозначается 1 или true, а отсутствие 0 или false.
SELECT * FROM Rooms WHERE has_kitchen = 1 AND has_internet= 1
6)Операторы IS NULL, BETWEEN, IN
//IS NULL
Оператор IS NULL позволяет узнать, равно ли проверяемое значение NULL, т.е. пустое ли значение.
SELECT * FROM Teacher
WHERE middle_name IS NULL;
//BETWEEN
Оператор BETWEEN min AND max позволяет узнать, расположено ли проверяемое значение столбца в интервале между min и max, включая сами значения min и max. Он идентичен условию:
SELECT * FROM Payments
WHERE unit_price BETWEEN 100 AND 500;
//IN
Оператор IN позволяет узнать, входит ли проверяемое значение столбца в список определённых значений.
SELECT * FROM FamilyMembers
WHERE status IN ('father', 'mother');
//Задачки
1.Выведите имена first_name и фамилии last_name студентов из таблицы Student, у кого отсутствует отчество middle_name 
SELECT first_name,last_name FROM Student WHERE middle_name IS NULL
2.Выведите резервации комнат (поля room_id, start_date, end_date) из таблицы Reservations, у которых итоговая стоимость аренды (поле total) находится в промежутке от 500 до 1200 включительно.
SELECT room_id, start_date, end_date FROM Reservations WHERE total BETWEEN 500 AND 1200
3.Выведите информацию о студентах из таблицы Student, у которых год рождения соответствует одному из перечисленных: 2000, 2002 и 2004.
SELECT * FROM Student WHERE YEAR(birthday) IN (2000,2002,2004);

7)Оператор LIKE И ESCAPE-символ
//Оператор LIKE используется при условных запросах, когда мы хотим узнать, соответствует ли строка определённому шаблону.
//Синтаксис
WHERE поле_таблицы [NOT] LIKE шаблон_строки
//Шаблон может включать следующие специальные символы:
Символ	Описание
%	Последовательность любых символов (число символов в последовательности может быть от 0 и более)
_	Любой единичный символ
//
SELECT email FROM Users
WHERE email LIKE '%@hotmail.%'
//Вывод - 
barjam@hotmail.com
metzzo@hotmail.com
kostas@hotmail.com
//ESCAPE-символ
ESCAPE-символ используется для экранирования специальных символов (% и \). В случае если вам нужно найти строки, вы можете использовать ESCAPE-символ.
// Пример для 3 %
SELECT job_id FROM Jobs
WHERE progress LIKE '3!%' ESCAPE '!';
// Задачка
1. Найдите всех членов семьи с фамилией "Quincey" и выведите поле member_name
SELECT member_name 
FROM FamilyMembers
WHERE member_name LIKE '%Quincey'
//
8)Оператор REGEXP
Оператор REGEXP (или его синоним RLIKE) в SQL используется для поиска и обработки строковых данных с помощью регулярных выражений. (берем когда трудные случаи шаблона LIKE)
Например, поиск по нескольким условиям или использование специальных символов и диапазонов, оператор REGEXP станет незаменимым инструментом.
//Специальные символы и структуры
Символы и структуры	Чему соответствует
*	0 или более экземпляров предшествующей строки
+	1 или более экземпляров предшествующих строк
.	Любой одиночный символ
?	0 или 1 экземпляр предшествующей строки
^	Соответствует началу строки
$	Соответствует окончанию строки
[abc]	Любой символ, указанный в квадратных скобках
[^abc]	Любой символ, не указанный в квадратных скобках
[A-Z], [А-Я]	Соответствует любой заглавной букве латинского и кириллического алфавита соответственно
[a-z], [а-я]	Соответствует любой строчной букве латинского и кириллического алфавита соответственно
[0-9]	Соответствует любой цифре
p1|p2|p3	Соответствует любому из паттернов p1 или p2 или p3
{n}	n экземпляров предыдущей строки
{m,n}	от m до n экземпляров предыдущей строки
//Примеры
1.SELECT * FROM Users WHERE name REGEXP '^John'
Это выражение ищет строки, начинающиеся с «John». Символ ^ указывает на начало строки.
2.SELECT * FROM  Subject WHERE name REGEXP '[ey]$'
Выведем все школьные предметы, название которых оканчивается на букву «e» или «y»
//
//Задачки
1.Найдите все жилые помещения (таблица Rooms), в адресе которых содержится строка «Avenue». В результирующей выборке выведите поля id и address. 
SELECT id,address FROM Rooms WHERE address REGEXP 'Avenue'
2.Выведите name, email пользователей, чей адрес электронной почты заканчивается на «@outlook.com» или «@live.com».
SELECT name,email FROM Users WHERE EMAIL REGEXP '@(outlook.com|live.com)$'
//
9)Сортировка, оператор ORDER BY
При выполнении SELECT запроса, строки по умолчанию возвращаются в неопределённом порядке. Фактический порядок строк в этом случае зависит от плана соединения и сканирования, а также от порядка расположения данных на диске, поэтому полагаться на него нельзя. Для упорядочивания записей используется конструкция ORDER BY.
(Где ASC и DESC - направление сортировки:
ASC - сортировка по возрастанию (по умолчанию)
DESC - сортировка по убыванию)
Например, выведем названия авиакомпаний в алфавитном порядке из таблицы Company: SELECT name FROM Company ORDER BY name;
//Для сортировки результатов по двум или более столбцам их следует указывать через запятую.
ORDER BY столбец_1 [ASC | DESC], столбец_2 [ASC | DESC];
Данные будут сортироваться по первому столбцу, но в случае если попадаются несколько записей с совпадающими значениями в первом столбце, то они сортируются по второму столбцу.
//Пример: Выведем информацию о полётах, отсортированную по городу вылета самолёта в порядке возрастания и по городу прибытия в аэропорт в порядке убывания, из таблицы Trip:
SELECT DISTINCT town_from, town_to FROM Trip
ORDER BY town_from, town_to DESC;
//Задачки
1. Для каждого отдельного платежа выведите идентификатор товара и сумму, потраченную на него, в отсортированном по убыванию этой суммы виде. Список платежей находится в таблице Payments.
Для вывода суммы используйте псевдоним sum.
SELECT good,unit_price*amount AS sum FROM Payments ORDER BY sum DESC
2.Выведите все данные членов семьи с фамилией Quincey из таблицы FamilyMembers и отсортируйте их по возрастанию сначала по столбцу status, а затем по member_name.
SELECT * FROM FamilyMembers WHERE member_name REGEXP 'Quincey$' ORDER BY status ASC, member_name ASC
//
10)Группировка, оператор GROUP BY
SELECT [литералы, агрегатные_функции, поля_группировки]
FROM имя_таблицы
GROUP BY поля_группировки;
//Для того, чтобы записи у нас образовали группы по типу жилья, мы должны после GROUP BY указать home_type, т.е. поле, по которому будет происходить группировка. 
SELECT home_type FROM Rooms
GROUP BY home_type
ВЫВОД:
home_type
Private room
Entire home/apt
Shared room
!!!!!Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные, т.е. при группировке по полю, содержащему NULL-значения, все такие строки попадут в одну группу
При использовании GROUP BY мы можем выводить только:
)литералы, т.е. указанное явным образом фиксированные значения.(SELECT home_type, "literal" FROM Rooms GROUP BY home_type)
)результаты агрегатных функций, т.е. вычисленные значения на основании набора значений.(SELECT home_type, AVG(price) as avg_price FROM Rooms GROUP BY home_type)
!!!Функция AVG принимает в качестве аргумента название поля, по которому мы хотим вычислить среднее значение для каждой группы.
)поля группировки. Мы можем их выводить, так как в рамках одной группы поля, по которым осуществлялась группировка, одинаковые.
///НУЖНЫЕ ШТУКИ ДЛЯ РАБОТЫ С ДАТАМИ И ВРЕМЕНЕМ 
TIMEDIFF(time_in, time_out) as flight_time  - ДЛЯ ВЫВОДА РАЗНИЦЫ ВО ВРЕМЕНИ В ФОРМАТЕ НН:ММ:SS
DATEDIFF(DATE_in, DATE_out) as VACATION  - ДЛЯ ВЫВОДА РАЗНИЦУ МЕЖДУ ДАТАМИ
12)Многотабличные запросы, JOIN
//Общая структура многотабличного запроса
SELECT поля_таблиц
FROM таблица_1
[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_2
    ON условие_соединения
[[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_n
    ON условие_соединения]
//Как можно увидеть по структуре, соединение бывает:
)внутренним INNER (по умолчанию)(подробнее в пункте 13)
)внешним OUTER, при этом внешнее соединение делится на левое LEFT, правое RIGHT и полное FULL(подробнее в пункте 14)
//Чтобы сопоставление работало, мы указываем как именно записи из двух разных таблиц должны находить друг друга. Это условие указывается после ON:
ON Payments.family_member = FamilyMembers.member_id(В большинстве случаев условием соединения является равенство столбцов таблиц (таблица_1.поле = таблица_2.поле), однако точно так же можно использовать и другие операторы сравнения.)
//Вывод всех столбцов из таблицы в многотабличном запросе. Таким же образом можно вывести все столбцы из нескольких таблиц:
SELECT Payments.*, FamilyMembers.* FROM Payments
INNER JOIN FamilyMembers
    ON Payments.family_member = FamilyMembers.member_id
//Псевдонимы для таблиц 
Псевдонимы задаются после имени таблицы с помощью ключевого слова AS:
SELECT id, name
FROM Passenger AS pass
13)Внутреннее соединение INNER JOIN
//Говоря о многотабличном запросе со внутренним соединением, общая структура выглядит так:
SELECT поля_таблиц
FROM таблица_1
[INNER] JOIN таблица_2
    ON условие_соединения
[[INNER] JOIN таблица_n
    ON условие_соединения]
!!!!Внутреннее соединение — соединение, при котором находятся пары записей из двух таблиц, удовлетворяющие условию соединения, тем самым образуя новую таблицу, содержащую поля из первой и второй исходных таблиц.
Например в нашем условии указано равенство полей Payments.good_id и Goods.good_id, то при внутреннем соединении в итоговой выборке окажутся только записи, где в обеих таблицах есть одинаковое значение good_id.
/////Для внутреннего соединения таблиц также можно использовать оператор WHERE. Например, вышеприведённый запрос, написанный с помощью INNER JOIN, будет выглядеть так:
SELECT family_member, member_name FROM Payments, FamilyMembers
    WHERE Payments.family_member = FamilyMembers.member_id
14)Внешнее соединение OUTER JOIN
///Внешнее соединение может быть трёх типов: левое (LEFT), правое (RIGHT) и полное (FULL). По умолчанию оно является полным.
!!!!Главным отличием внешнего соединения от внутреннего является то, что оно обязательно возвращает все строки одной (LEFT, RIGHT) или двух таблиц (FULL).
///Внешнее левое соединение (LEFT OUTER JOIN)
Соединение, которое возвращает все значения из левой таблицы, соединённые с соответствующими значениями из правой таблицы, если они удовлетворяют условию соединения, или заменяет их на NULL в обратном случае.
///Внешнее правое соединение (RIGHT OUTER JOIN)
Соединение, которое возвращает все значения из правой таблицы, соединённые с соответствующими значениями из левой таблицы, если они удовлетворяют условию соединения, или заменяет их на NULL в обратном случае.
///Внешнее полное соединение (FULL OUTER JOIN)
Соединение, которое выполняет внутреннее соединение записей и дополняет их левым внешним соединением и правым внешним соединением.
SELECT *
FROM левая_таблица
LEFT JOIN правая_таблица
   ON правая_таблица.ключ = левая_таблица.ключ

UNION ALL

SELECT *
FROM левая_таблица
RIGHT JOIN правая_таблица
ON правая_таблица.ключ = левая_таблица.ключ
 WHERE левая_таблица.ключ IS NULL
15)Ограничение выборки, оператор LIMIT
Оператор LIMIT позволяет извлечь определённый диапазон записей из одной или нескольких таблиц.
///Общая структура запроса с оператором LIMIT
SELECT поля_выборки
FROM список_таблиц
LIMIT [количество_пропущенных_записей,] количество_записей_для_вывода;
///Оператор LIMIT реализован не во всех СУБД, например, в MSSQL для вывода записей с начала таблицы используется оператор TOP, а для тех случаев, когда необходимо сделать отступ от начала таблицы, предназначена конструкция OFFSET FETCH.
///Для того, чтобы вывести строки с 3 по 5, нужно использовать такой запрос:
SELECT * FROM Company LIMIT 2, 3;
// Первые 2 строки 
SELECT * FROM Company LIMIT 2;
16)Подзапросы
Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.
Как и любой другой SQL запрос, подзапрос возвращает результирующий набор, который может быть одним из следующих:
)одна строка и один столбец;
)нескольких строк с одним столбцом;
)нескольких строк с несколькими столбцами.
///Получим список всех бронирований самого дорогого на данный момент жилого помещения:
SELECT * FROM Reservations
    WHERE Reservations.room_id = (
        SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
    )
17)Подзапрос с одной строкой с одним столбцом
Данный тип подзапросов также известен как скалярный подзапрос.
Он может использоваться в различных частях основного SQL запроса, но чаще всего он используется в условиях ограничений выборки с помощью операторов сравнения (=, <>, >, <).
////Таким же образом можно использовать скалярные подзапросы для фильтрации строк с помощью WHERE, используя операторы сравнения.
SELECT * FROM FamilyMembers
    WHERE birthday = (SELECT MAX(birthday) FROM FamilyMembers);
member_id	status	member_name	birthday
8	daughter	Wednesday Addams	2005-01-13T00:00:00.000Z
/////С помощью данного запроса возможно получить самого младшего члена семьи. Подзапрос в данном случае необходим для получения максимальной даты рождения, которая затем используется в основном запросе для фильтрации строк.
18)Подзапросы с несколькими строками и одним столбцом
!!!!Если подзапрос возвращает более одной строки, его нельзя просто использовать с операторами сравнения.
//Подзапрос и оператор ALL
С помощью оператора ALL мы можем сравнивать отдельное значение с каждым значением в наборе, полученным подзапросом.  При этом данное условие вернёт TRUE, только если все сравнения отдельного значения со значениями в наборе вернут TRUE.
///Например, нижеприведённый синтетический запрос проверяет для всех ли жилых помещений выполняется условие, что оно дешевле чем 200.
SELECT 200 > ALL(SELECT price FROM Rooms)
///Подзапрос и оператор IN
Оператор IN проверяет входит ли конкретное значение в набор значений. В качестве такого набора как раз может использоваться подзапрос, возвращающий несколько строк с одним столбцом.
////SELECT * FROM Users WHERE id IN (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150)
///Подзапрос и оператор ANY
Условное выражение с ANY имеет схожее поведение, но оно возвращает TRUE, если хотя бы одно сравнение отдельного значения со значением в наборе вернёт TRUE.
//SELECT * FROM Users WHERE id = ANY (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
19)Многостолбцовые подзапросы
Сравнение по нескольким столбцам
SQL поддерживает сравнение не только по одной колонке, но позволяет попарно сравнивать значения в основном запросе со значениями в подзапросе.
///SQL поддерживает сравнение не только по одной колонке, но позволяет попарно сравнивать значения в основном запросе со значениями в подзапросе.
SELECT * FROM Reservations
    WHERE (room_id, price) IN (SELECT id, price FROM Rooms);
20)Коррелированные подзапросы
Все предыдущие рассматриваемые подзапросы были некоррелированные (независимые). Они могли выполняться автономно от основного запроса и мы могли посмотреть, что они возвращают перед тем, как их результат будет использоваться в основном запросе.
Коррелированные же подзапросы ссылаются на один или несколько столбцов основного запроса.
Например, следующий коррелируемый подзапрос находит кто и сколько потратил:
SELECT FamilyMembers.member_name, (
    SELECT SUM(Payments.unit_price * Payments.amount)
    FROM Payments
    WHERE Payments.family_member = FamilyMembers.member_id
) AS total_spent
FROM FamilyMembers;
///Коррелированный подзапрос отличается от некоррелированного подзапроса тем, что он выполняется не один раз перед выполнением запроса, в который он вложен, а для каждой строки, которая может быть включена в окончательный результат.
!!!!!Следует обратить внимание на то, что использование коррелированных подзапросов может вызвать проблемы с производительностью, особенно если содержащий запрос возвращает много строк, так как коррелированный подзапрос будет выполняться для каждой строки содержащего запроса отдельно.
21)Обобщенное табличное выражение, оператор WITH
Обобщённое табличное выражение или CTE (Common Table Expressions) - это временный результирующий набор данных, к которому можно обращаться в последующих запросах. Для написания обобщённого табличного выражения используется оператор WITH.
WITH Aeroflot_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")

SELECT plane, COUNT(plane) AS amount FROM Aeroflot_trips GROUP BY plane;
///Выражение с WITH считается «временным», потому что результат не сохраняется где-либо на постоянной основе в схеме базы данных,
а действует как временное представление, которое существует только на время выполнения запроса, то есть оно доступно только во время выполнения операторов SELECT, INSERT, UPDATE, DELETE или MERGE.
///Порядок использования оператора WITH:
1)Ввести оператор WITH
2)Указать название обобщённого табличного выражения
3)Опционально: определить названия для столбцов получившегося табличного выражения, разделённых знаком запятой
4)Ввести AS и далее подзапрос, результат которого можно будет использовать в других частях SQL запроса, используя имя, определённое на 2 этапе
5)Опционально: если необходимо более одного табличного выражения, то ставится запятая и повторяются шаги 2-4
///Cоздаём табличное выражение Aeroflot_trips, но с переименованными колонками
WITH Aeroflot_trips (aeroflot_plane, town_from, town_to) AS
    (SELECT plane, town_from, town_to FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")

SELECT * FROM Aeroflot_trips;
///С помощью оператора WITH определяем несколько табличных выражений
WITH Aeroflot_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot"),
    Don_avia_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Don_avia")

SELECT * FROM Don_avia_trips UNION SELECT * FROM  Aeroflot_trips;
///Работа с рекурсией в CTE
CTE также могут быть использованы для выполнения рекурсивных запросов, которые позволяют итеративно обрабатывать данные, например, для работы с иерархическими структурами данных, такими как «руководитель — подчинённый».
Рекурсивное CTE состоит из двух частей, разделенных оператором UNION ALL:
1)Начальный набор данных, который не содержит рекурсивных ссылок.
2)Рекурсивная часть: запрос, который ссылается на CTE, чтобы продолжить рекурсию.
//
WITH RECURSIVE название_cte (столбец_1, столбец_2, ...) AS (
    -- Начальный набор данных
    SELECT столбец_1, столбец_2, ...
    FROM таблица
    WHERE условие

    UNION ALL

    -- Рекурсивная часть
    SELECT столбец_1, столбец_2, ...
    FROM название_cte
    INNER JOIN таблица ON название_cte.столбец = таблица.столбец
    WHERE условие
)

SELECT * FROM название_cte;
///Пример: иерархия руководителей и подчинённых
Требуется найти всех подчинённых John Smith (id=1) на всех уровнях иерархии.
WITH RECURSIVE Subordinates AS (
    -- Начальный набор данных
    SELECT id, name, managerId
    FROM Employees
    WHERE managerId = 1

    UNION ALL

    -- Рекурсивная часть: подчинённые подчинённых
    SELECT e.id, e.name, e.managerId
    FROM Employees e
    INNER JOIN Subordinates s ON e.managerId = s.id
)

SELECT * FROM Subordinates;
///Шаги выполнения рекурсивного CTE
Начальный набор данных: выбираются все сотрудники, у которых managerId=1 (непосредственные подчинённые John Smith).
Рекурсивная часть: для каждого сотрудника, выбранного в начальном наборе данных, выбираются их подчинённые (где managerId равен id выбранного сотрудника).
Объединение: результаты начального набора данных и рекурсивной частей объединяются с помощью UNION ALL.
Рекурсия: процесс повторяется для каждого нового набора подчинённых, пока не будут выбраны все уровни иерархии.
//
22)Объединение запросов, оператор Union
Результаты выполнения SQL запросов можно объединять. Для этого существует оператор UNION.
///Общая структура запроса с оператором UNION
SELECT поля_таблиц FROM список_таблиц ...
UNION [ALL]
SELECT поля_таблиц FROM список_таблиц ... ;
!!!!UNION по умолчанию убирает повторения в результирующей таблице. Для отображения с повторением есть необязательный параметр ALL.
)Не путайте операции объединения запросов с операциями объединения таблиц. Для этого служит оператор JOIN.
)Не путайте операции объединения запросов с подзапросами. Подзапросы выполняются для связанных таблиц.
///Объединение таблиц оператором UNION выполняется для таблиц никак не связанных, но со схожей структурой.
Для корректной работы UNION нужно, чтобы результирующие таблицы каждого из SQL запросов имели одинаковое число столбцов, с одним и тем же типом данных и в той же самой последовательности.
///Существует два других оператора, чьё поведение крайне схоже с UNION:
INTERSECT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые имеют совпадения во втором элементе SELECT.
EXCEPT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые не имеют совпадения во втором элементе SELECT.
Задачка:
Выведите полные имена (поля first_name, middle_name и last_name) всех студентов и преподавателей.
select first_name, middle_name, last_name from Teacher
union
select first_name, middle_name, last_name from Student
23)Условная логика, оператор CASE
Что такое условная логика?
Под условной логикой понимается наличие у программы нескольких путей выполнения в зависимости от каких-то условий.
Например, в базе данных «Расписание» есть таблица Student с полем birthday, отражающим дату рождения студента.
Допустим, в выборке необходимо отобразить не саму дату рождения, а текстовое значение «Совершеннолетний» или «Несовершеннолетний» в зависимости от того, есть ли студенту 18 лет.
Это и есть пример условной логики, при которой должно вывестись либо одно значение, либо другое в зависимости от конкретного условия.
///Реализация такого запроса с помощью CASE может выглядеть следующим образом:
SELECT first_name, last_name,
CASE
  WHEN TIMESTAMPDIFF(YEAR, birthday, NOW()) >= 18 THEN "Совершеннолетний"
  ELSE "Несовершеннолетний"
END AS status
FROM Student
///
Синтаксис поискового выражения CASE
CASE
    WHEN условие_1 THEN возвращаемое_значение_1
    WHEN условие_2 THEN возвращаемое_значение_2
    WHEN условие_n THEN возвращаемое_значение_n
    [ELSE возвращаемое_значение_по_умолчанию]
END
!!!Если ни одно из предложенных условий не будет выполнено, то вернётся NULL или возвращаемое_значение_по_умолчанию, если была использована конструкция ELSE.
///
24)Условная функция IF
/Синтаксис IF
IF(условное_выражение, значение_1, значение_2);
Если условное выражение, передаваемое в качестве первого аргумента в функцию IF, истинно, функция вернёт значение второго аргумента значение_1, иначе возвращается значение третьего аргумента значение_2.
///Простое сравнение двух чисел. Так как 10 не больше 20, функция вернёт "FALSE".
SELECT IF(10 > 20, "TRUE", "FALSE");
IF(10 > 20, "TRUE", "FALSE")
FALSE
///
Функции IFNULL и NULLIF
Помимо функции IF, в SQL также есть более простые, но менее универсальные функции IFNULL и NULLIF, направленные на обработку NULL значений.
)Функция IFNULL возвращает значение, переданное первым аргументом, если оно не равно NULL, иначе возвращает альтернативное_значение.
IFNULL(значение, альтернативное_значение);
))Если первый аргумент не равен NULL, то вернётся именно он.
))Если первый аргумент равен NULL, то вернётся значение, переданное вторым аргументом.
)Функция NULLIF возвращает NULL, если значение_1 равно значению_2, в противном случае возвращает значение_1.
NULLIF(значение_1, значение_2);
))Если значение первого аргумента равно значению второго аргумента, то возвращается NULL.
SELECT NULLIF("SQL Academy", "SQL Academy") AS sql_trainer;
))Если значения первого и второго аргумента различаются, то возвращается значение первого аргумента.
////
25)Добавление данных, оператор INSERT
Для добавления новых записей в таблицу предназначен оператор INSERT.
///Общая структура запроса с оператором INSERT
INSERT INTO имя_таблицы [(поле_таблицы, ...)]
VALUES (значение_поля_таблицы, ...)
| SELECT поле_таблицы, ... FROM имя_таблицы ..
Значения можно вставлять перечислением с помощью слова VALUES, перечислив их в круглых скобках через запятую или c помощью оператора SELECT.
ПРИМЕРЫ С РАЗНЫМ СИНТАКСИСОМ
1.Используя синтаксис INSERT INTO ... SELECT
INSERT INTO Goods (good_id, good_name, type)
SELECT 20, 'Table', 2;
2.Используя синтаксис INSERT INTO ... VALUES (...)
INSERT INTO Goods (good_id, good_name, type)
VALUES (20, 'Table', 2);
26)Первичный ключ при добавлении новой записи
!!!Следует помнить, что первичный ключ таблицы является уникальным значением и добавление уже существующего значения приведёт к ошибке.
Решением может быть дополнительный запрос, направленный на выявление максимального значения первичного ключа для генерации нового уникального значения.
INSERT INTO Goods SELECT MAX(good_id) + 1, 'Table', 2 FROM Goods;
27)Обновление данных, оператор UPDATE
Для редактирования существующих записей в таблицах существует SQL оператор UPDATE.
////Общая структура запроса с оператором UPDATE
UPDATE имя_таблицы
SET поле_таблицы1 = значение_поля_таблицы1,
    поле_таблицыN = значение_поля_таблицыN
[WHERE условие_выборки]
///
ПРИМЕР
Так, например, если нужно изменить имя, то запрос будет иметь следующий вид:
UPDATE FamilyMembers
SET member_name = "Andie Anthony"
WHERE member_name = "Andie Quincey";
///
!!!Будьте внимательны, когда обновляете данные. Если вы пропустите оператор WHERE, то будут обновлены все записи в таблице.
28)Вычисляемые значения
В запросах на обновление данных можно менять значения, опираясь на предыдущее значение.
UPDATE Payments
SET unit_price = unit_price * 2;
!!!Разрешается также значения одних столбцов присваивать другим столбцам. Но при этом, естественно, типы столбцов должны быть совместимыми.
29)Удаление данных, оператор DELETE
Для этого в SQL предусмотрены операторы DELETE и TRUNCATE, из которых наиболее универсальным и безопасным является первый вариант.
///Общая структура запроса с оператором DELETE
DELETE имя_таблицы (либо что нужно удалить)FROM имя_таблицы
[WHERE условие_отбора_записей];
///!!Если условие отбора записей WHERE отсутствует, то будут удалены все записи указанной таблицы.
Оптимизатор запросов СУБД MySQL автоматически использует оператор TRUNCATE, если оператор DELETE не содержит условия WHERE или конструкции LIMIT.
Однако у оператора TRUNCATE есть ряд отличий:
Не срабатывают триггеры, в частности, триггер удаления
Удаляет все строки в таблице, не записывая при этом удаление отдельных строк данных в журнал транзакций
Сбрасывает счётчик идентификаторов до начального значения
Чтобы использовать, необходимы права на изменение таблицы
///Удаление записей при многотабличных запросах
Если в DELETE запросе используется JOIN, то необходимо указать из каких(ой) именно таблиц(ы) требуется удалять записи.
Например, нам необходимо удалить все бронирования жилья, в котором отсутствует кухня. Тогда запрос будет выглядеть следующим образом:
DELETE Reservations FROM
Reservations JOIN Rooms ON
Reservations.room_id = Rooms.id
WHERE Rooms.has_kitchen = false;
30)Числовой тип данных в SQL
При вычислениях можно использовать все стандартные арифметические операции (+, -, *, / и прочие) и изменять приоритеты вычислений с помощью скобок.
Имя функции	Описание
POW(num, power)	Вычисляет число в указанной степени
SQRT(num)	Вычисляет квадратный корень числа
LOG(base, num)	Вычисляет логарифм числа по указанному основанию
EXP(num)	Вычисляет enum
SIN(num)	Вычисляет синус числа
COS(num)	Вычисляет косинус числа
TAN(num)	Вычисляет тангенс числа
/Функции CEIL, FLOOR направлены на то, чтобы округлять число к ближайшему целому числу в большую и в меньшую сторону соответственно.
/Для округления к ближайшему целому числу есть функция ROUND, которая любое число, десятичная часть которого больше или равна 0.5, 
округляет в большую сторону, иначе в меньшую.Функция ROUND также позволяет округлять число до некоторой части десятичных знаков после запятой.
/Функция TRUNCATE аналогична функции ROUND, она также способна принимать 2-й необязательный параметр, только вместо округления она просто отбрасывает ненужные цифры.
31)Работа со знаковыми числами
При работе с числовыми данными, в которых возможно наличие отрицательных значений, могут быть полезными функции SIGN и ABS.
Функция SIGN возвращает значение -1, если число отрицательно, 0, если число нулевое и 1, если число положительное.
Функция ABS возвращает абсолютное значение числа.
32)Дата и время в SQL
Генерация временных данных
Временные данные можно получить одним из следующих способов:
)скопировать данные из существующего столбца с времéнным типом данных
)задать дату и время через строковое представление
)получить временны́е данные путём вызова встроенных функций, возвращающих временной тип данных
////
Тип	Формат по умолчанию
DATE	YYYY-MM-DD
DATETIME	YYYY-MM-DD hh:mm:ss
TIMESTAMP	YYYY-MM-DD hh:mm:ss
TIME	hhh:mm:sss
YEAR	YYYY - полный формат
YY или Y - сокращённый формат, который возвращает год в пределах 2000-2069 для значений 0-69 и год в пределах 1970-1999 для значений 70-99
Примеры валидного задания временных значений через строковое представление:
SELECT  CAST("2022-06-16 16:37:23" AS DATETIME) AS datetime_1,
        CAST("2014/02/22 16*37*22" AS DATETIME) AS datetime_2,
        CAST("20220616163723" AS DATETIME) AS datetime_3,
        CAST("2021-02-12" AS DATE) AS date_1,
        CAST("160:23:13" AS TIME) AS time_1,
        CAST("89" AS YEAR) AS year
///Если необходимо получить временные данные из строки, которая не соответствует ни одному формату,
который принимает функция CAST, то можно использовать встроенную функцию STR_TO_DATE, которая принимает произвольную строку, содержащую дату, и формат, описывающий её.
SELECT STR_TO_DATE('November 13, 1998', '%M %d, %Y') AS date;
///Для генерации же текущей даты или времени: CURDATE, CURTIME и NOW.
///Критерий	DATETIME	TIMESTAMP
Диапазон	от 1000-01-01 00:00:00  	от 1970-01-01 00:00:00
            до 9999-12-31 23:59:59      до 2038-01-19 03:14:07
Часовой пояс	Не учитывается          Учитывается
Отображается в таком виде, в котором дата была установлена	При выборках отображается с учётом текущего часового пояса сервера БД
////Часовые пояса
SET GLOBAL time_zone = '+03:00';    // глобально
SET time_zone = '+03:00';           // для текущего пользователя
SET @@session.time_zone = '+03:00'; // для текущей пользовательской сессии
33) Функции преобразования типов, CAST
